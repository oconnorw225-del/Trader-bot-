/**
 * Auto-Documentor Service
 * Generates automated reports and documentation for the auto-start system
 */

import fs from 'fs/promises';
import path from 'path';

/**
 * AutoDocumentor class for generating reports and documentation
 */
export class AutoDocumentor {
  constructor(options = {}) {
    this.outputDir = options.outputDir || path.join(process.cwd(), 'reports');
    this.reportFormat = options.reportFormat || 'markdown';
  }

  /**
   * Ensure output directory exists
   */
  async ensureOutputDir() {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
    } catch (error) {
      console.error('Error creating output directory:', error);
    }
  }

  /**
   * Generate a daily report of bot activities
   * @param {Object} data - Data for the report
   * @returns {Promise<string>} Path to generated report
   */
  async generateDailyReport(data = {}) {
    try {
      await this.ensureOutputDir();

      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `daily-report-${timestamp}.md`;
      const filepath = path.join(this.outputDir, filename);

      const report = this.buildDailyReport(data);

      await fs.writeFile(filepath, report, 'utf-8');
      console.log(`✅ Daily report generated: ${filepath}`);

      return filepath;
    } catch (error) {
      console.error('Error generating daily report:', error);
      throw error;
    }
  }

  /**
   * Build the daily report content
   * @param {Object} data - Report data
   * @returns {string} Report content
   */
  buildDailyReport(data) {
    const {
      totalJobsScanned = 0,
      jobsCompleted = 0,
      totalEarnings = 0,
      platformsConnected = 0,
      errors = 0,
      activeJobs = [],
      topEarningPlatforms = [],
      jobsByStrategy = {},
      averageCompletionTime = 0
    } = data;

    const date = new Date().toISOString();
    const successRate = totalJobsScanned > 0 ? ((jobsCompleted / totalJobsScanned) * 100).toFixed(2) : 0;

    return `# Auto-Start Daily Report
Generated: ${date}

## Summary
- **Total Jobs Scanned**: ${totalJobsScanned}
- **Jobs Completed**: ${jobsCompleted}
- **Success Rate**: ${successRate}%
- **Total Earnings**: $${totalEarnings.toFixed(2)}
- **Platforms Connected**: ${platformsConnected}
- **Errors**: ${errors}
- **Active Jobs**: ${activeJobs.length}

## Earnings Breakdown
${topEarningPlatforms.length > 0 ? topEarningPlatforms.map(p => 
  `- **${p.platform}**: $${p.earnings.toFixed(2)} (${p.jobs} jobs)`
).join('\n') : '- No earnings yet'}

## Strategy Performance
${Object.entries(jobsByStrategy).length > 0 ? Object.entries(jobsByStrategy).map(([strategy, count]) => 
  `- **${strategy}**: ${count} jobs`
).join('\n') : '- No strategy data available'}

## Active Jobs
${activeJobs.length > 0 ? activeJobs.map(job => 
  `- ${job.title} (${job.platform}) - $${job.payment?.toFixed(2)}`
).join('\n') : '- No active jobs'}

## Performance Metrics
- **Average Completion Time**: ${averageCompletionTime.toFixed(2)} minutes
- **Error Rate**: ${totalJobsScanned > 0 ? ((errors / totalJobsScanned) * 100).toFixed(2) : 0}%

---
*This report was automatically generated by AutoDocumentor*
`;
  }

  /**
   * Generate a platform connection report
   * @param {Array} platforms - Platform connection data
   * @returns {Promise<string>} Path to generated report
   */
  async generatePlatformReport(platforms = []) {
    try {
      await this.ensureOutputDir();

      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `platform-report-${timestamp}.md`;
      const filepath = path.join(this.outputDir, filename);

      const report = this.buildPlatformReport(platforms);

      await fs.writeFile(filepath, report, 'utf-8');
      console.log(`✅ Platform report generated: ${filepath}`);

      return filepath;
    } catch (error) {
      console.error('Error generating platform report:', error);
      throw error;
    }
  }

  /**
   * Build platform report content
   * @param {Array} platforms - Platform data
   * @returns {string} Report content
   */
  buildPlatformReport(platforms) {
    const date = new Date().toISOString();
    const connectedCount = platforms.filter(p => p.status === 'connected').length;

    return `# Platform Connection Report
Generated: ${date}

## Overview
- **Total Platforms**: ${platforms.length}
- **Connected**: ${connectedCount}
- **Disconnected**: ${platforms.length - connectedCount}

## Platform Details
${platforms.map(p => `
### ${p.platform}
- **Status**: ${p.status}
- **Last Connected**: ${p.lastConnected || 'Never'}
- **Successful Requests**: ${p.successfulRequests || 0}
- **Failed Requests**: ${p.failedRequests || 0}
- **Connection Attempts**: ${p.connectionAttempts || 0}
${p.lastError ? `- **Last Error**: ${p.lastError}` : ''}
`).join('\n')}

---
*This report was automatically generated by AutoDocumentor*
`;
  }

  /**
   * Generate error log report
   * @param {Array} errors - Error data
   * @returns {Promise<string>} Path to generated report
   */
  async generateErrorReport(errors = []) {
    try {
      await this.ensureOutputDir();

      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `error-report-${timestamp}.md`;
      const filepath = path.join(this.outputDir, filename);

      const report = this.buildErrorReport(errors);

      await fs.writeFile(filepath, report, 'utf-8');
      console.log(`✅ Error report generated: ${filepath}`);

      return filepath;
    } catch (error) {
      console.error('Error generating error report:', error);
      throw error;
    }
  }

  /**
   * Build error report content
   * @param {Array} errors - Error data
   * @returns {string} Report content
   */
  buildErrorReport(errors) {
    const date = new Date().toISOString();
    const errorsByType = errors.reduce((acc, err) => {
      acc[err.type] = (acc[err.type] || 0) + 1;
      return acc;
    }, {});

    return `# Error Report
Generated: ${date}

## Summary
- **Total Errors**: ${errors.length}

## Errors by Type
${Object.entries(errorsByType).map(([type, count]) => 
  `- **${type}**: ${count}`
).join('\n')}

## Recent Errors (Last 10)
${errors.slice(-10).reverse().map((err, idx) => `
### ${idx + 1}. ${err.type || 'Unknown Error'}
- **Time**: ${err.timestamp || 'Unknown'}
- **Message**: ${err.message || 'No message'}
- **Platform**: ${err.platform || 'N/A'}
- **Job**: ${err.jobId || 'N/A'}
${err.stack ? `- **Stack**: \`\`\`\n${err.stack}\n\`\`\`` : ''}
`).join('\n')}

---
*This report was automatically generated by AutoDocumentor*
`;
  }

  /**
   * Generate a summary report
   * @param {Object} data - Summary data
   * @returns {Promise<string>} Path to generated report
   */
  async generateSummaryReport(data = {}) {
    try {
      await this.ensureOutputDir();

      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `summary-${timestamp}.md`;
      const filepath = path.join(this.outputDir, filename);

      const report = this.buildSummaryReport(data);

      await fs.writeFile(filepath, report, 'utf-8');
      console.log(`✅ Summary report generated: ${filepath}`);

      return filepath;
    } catch (error) {
      console.error('Error generating summary report:', error);
      throw error;
    }
  }

  /**
   * Build summary report content
   * @param {Object} data - Summary data
   * @returns {string} Report content
   */
  buildSummaryReport(data) {
    const date = new Date().toISOString();
    const {
      botState = {},
      platformConnections = [],
      recentJobs = [],
      statistics = {}
    } = data;

    return `# Auto-Start System Summary
Generated: ${date}

## Bot Status
- **Running**: ${botState.isRunning ? 'Yes' : 'No'}
- **Strategy**: ${botState.strategy || 'N/A'}
- **Max Concurrent Jobs**: ${botState.maxConcurrentJobs || 0}
- **Active Jobs**: ${botState.activeJobs?.length || 0}
- **Total Completed**: ${botState.totalJobsCompleted || 0}
- **Total Earnings**: $${(botState.totalEarnings || 0).toFixed(2)}

## Platform Status
${platformConnections.map(p => 
  `- **${p.platform}**: ${p.status}`
).join('\n')}

## Recent Jobs (Last 5)
${recentJobs.slice(-5).reverse().map(job => 
  `- ${job.title} (${job.platform}) - $${job.payment?.toFixed(2)} - ${job.status}`
).join('\n')}

## Statistics
- **Total Jobs**: ${statistics.totalJobs || 0}
- **Average Earnings**: $${(statistics.averageEarnings || 0).toFixed(2)}
- **Success Rate**: ${(statistics.successRate || 0).toFixed(2)}%

---
*This report was automatically generated by AutoDocumentor*
`;
  }

  /**
   * Export data to JSON format
   * @param {Object} data - Data to export
   * @param {string} filename - Output filename
   * @returns {Promise<string>} Path to exported file
   */
  async exportToJSON(data, filename) {
    try {
      await this.ensureOutputDir();

      const filepath = path.join(this.outputDir, filename);
      await fs.writeFile(filepath, JSON.stringify(data, null, 2), 'utf-8');

      console.log(`✅ Data exported to JSON: ${filepath}`);
      return filepath;
    } catch (error) {
      console.error('Error exporting to JSON:', error);
      throw error;
    }
  }
}

export default AutoDocumentor;
